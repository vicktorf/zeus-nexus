apiVersion: apps/v1
kind: Deployment
metadata:
  name: zeus-core
  namespace: ac-agentic
  labels:
    app: zeus-core
    component: api
    part-of: zeus-nexus
spec:
  replicas: 2
  selector:
    matchLabels:
      app: zeus-core
  template:
    metadata:
      labels:
        app: zeus-core
        component: api
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8000"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: zeus-service-account
      containers:
      - name: zeus-core
        image: python:3.11-slim
        command: ["/bin/bash"]
        args:
        - -c
        - |
          pip install fastapi uvicorn prometheus-client langchain openai redis psycopg2-binary httpx asyncpg
          cat > /app/main.py << 'EOF'
          import os
          import asyncio
          import json
          import uuid
          from datetime import datetime
          from typing import Dict, List, Optional, Any
          
          import redis
          import asyncpg
          import httpx
          from fastapi import FastAPI, HTTPException, BackgroundTasks
          from fastapi.middleware.cors import CORSMiddleware
          from pydantic import BaseModel
          from prometheus_client import Counter, Histogram, Gauge, generate_latest
          from fastapi.responses import Response
          
          # Metrics
          request_count = Counter('zeus_requests_total', 'Total requests', ['method', 'endpoint'])
          request_duration = Histogram('zeus_request_duration_seconds', 'Request duration')
          active_agents = Gauge('zeus_active_agents', 'Number of active agents')
          
          app = FastAPI(title="Zeus Nexus Core", version="1.0.0", description="AI Pantheon Command Center")
          
          app.add_middleware(
              CORSMiddleware,
              allow_origins=["*"],
              allow_credentials=True,
              allow_methods=["*"],
              allow_headers=["*"],
          )
          
          # Models
          class ChatMessage(BaseModel):
              message: str
              user_id: Optional[str] = "anonymous"
              session_id: Optional[str] = None
              agent_preference: Optional[str] = None
          
          class AgentResponse(BaseModel):
              agent_name: str
              response: str
              confidence: float
              execution_time: float
          
          class TaskRequest(BaseModel):
              task_type: str
              agent_name: str
              input_data: Dict[str, Any]
          
          # Global connections
          redis_client = None
          db_pool = None
          
          async def startup():
              global redis_client, db_pool
              
              # Redis connection
              redis_url = os.getenv('REDIS_URL', 'redis://redis.ac-agentic.svc.cluster.local:6379')
              redis_client = redis.from_url(redis_url, decode_responses=True)
              
              # PostgreSQL connection pool
              postgres_url = os.getenv('POSTGRES_URL', 'postgresql://zeus:zeus123@postgresql.ac-agentic.svc.cluster.local:5432/zeus')
              db_pool = await asyncpg.create_pool(postgres_url)
              
              print("Zeus Nexus Core initialized successfully!")
          
          @app.on_event("startup")
          async def startup_event():
              await startup()
          
          @app.get("/")
          async def root():
              return {"message": "âš¡ Zeus Nexus Core API", "version": "1.0.0", "status": "active"}
          
          @app.get("/health")
          async def health_check():
              try:
                  # Check Redis
                  redis_client.ping()
                  
                  # Check PostgreSQL
                  async with db_pool.acquire() as conn:
                      await conn.fetchval("SELECT 1")
                  
                  return {
                      "status": "healthy",
                      "timestamp": datetime.utcnow().isoformat(),
                      "services": {
                          "redis": "healthy",
                          "postgresql": "healthy"
                      }
                  }
              except Exception as e:
                  raise HTTPException(status_code=503, detail=f"Health check failed: {str(e)}")
          
          @app.get("/metrics")
          async def metrics():
              return Response(generate_latest(), media_type="text/plain")
          
          @app.get("/agents")
          async def list_agents():
              try:
                  async with db_pool.acquire() as conn:
                      agents = await conn.fetch("SELECT * FROM agents ORDER BY name")
                      return [dict(agent) for agent in agents]
              except Exception as e:
                  raise HTTPException(status_code=500, detail=f"Failed to fetch agents: {str(e)}")
          
          @app.get("/agents/{agent_name}/health")
          async def check_agent_health(agent_name: str):
              try:
                  async with db_pool.acquire() as conn:
                      agent = await conn.fetchrow("SELECT * FROM agents WHERE name = $1", agent_name)
                      if not agent:
                          raise HTTPException(status_code=404, detail="Agent not found")
                  
                  # Check agent health
                  async with httpx.AsyncClient(timeout=5.0) as client:
                      response = await client.get(f"{agent['endpoint']}/health")
                      if response.status_code == 200:
                          return {"agent": agent_name, "status": "healthy", "endpoint": agent['endpoint']}
                      else:
                          return {"agent": agent_name, "status": "unhealthy", "endpoint": agent['endpoint']}
              except Exception as e:
                  return {"agent": agent_name, "status": "error", "error": str(e)}
          
          @app.post("/chat")
          async def chat(message: ChatMessage):
              request_count.labels(method="POST", endpoint="/chat").inc()
              
              try:
                  session_id = message.session_id or str(uuid.uuid4())
                  
                  # Simple agent routing logic
                  agent_map = {
                      "project": "athena",
                      "monitor": "ares", 
                      "sales": "apollo",
                      "docs": "clio",
                      "cloud": "hephaestus",
                      "crm": "hermes",
                      "learn": "mnemosyne"
                  }
                  
                  # Determine agent based on message content or preference
                  selected_agent = message.agent_preference
                  if not selected_agent:
                      for keyword, agent in agent_map.items():
                          if keyword in message.message.lower():
                              selected_agent = agent
                              break
                      else:
                          selected_agent = "athena"  # default
                  
                  # Get agent endpoint
                  async with db_pool.acquire() as conn:
                      agent = await conn.fetchrow("SELECT * FROM agents WHERE name = $1", selected_agent)
                      if not agent:
                          raise HTTPException(status_code=404, detail=f"Agent {selected_agent} not found")
                  
                  # Call agent
                  async with httpx.AsyncClient(timeout=30.0) as client:
                      agent_response = await client.post(
                          f"{agent['endpoint']}/process",
                          json={"message": message.message, "session_id": session_id}
                      )
                      
                      if agent_response.status_code == 200:
                          result = agent_response.json()
                          
                          # Store conversation
                          async with db_pool.acquire() as conn:
                              await conn.execute("""
                                  INSERT INTO conversations (session_id, user_id, agent_name, message, response, metadata)
                                  VALUES ($1, $2, $3, $4, $5, $6)
                              """, session_id, message.user_id, selected_agent, message.message, 
                              result.get('response', ''), json.dumps(result.get('metadata', {})))
                          
                          return {
                              "session_id": session_id,
                              "agent": selected_agent,
                              "response": result.get('response', 'No response'),
                              "metadata": result.get('metadata', {}),
                              "timestamp": datetime.utcnow().isoformat()
                          }
                      else:
                          raise HTTPException(status_code=500, detail=f"Agent call failed: {agent_response.status_code}")
              
              except Exception as e:
                  raise HTTPException(status_code=500, detail=f"Chat processing failed: {str(e)}")
          
          @app.post("/tasks")
          async def create_task(task: TaskRequest):
              try:
                  task_id = str(uuid.uuid4())
                  
                  # Store task
                  async with db_pool.acquire() as conn:
                      await conn.execute("""
                          INSERT INTO tasks (task_id, agent_name, task_type, status, input_data)
                          VALUES ($1, $2, $3, $4, $5)
                      """, task_id, task.agent_name, task.task_type, "pending", json.dumps(task.input_data))
                  
                  return {"task_id": task_id, "status": "created"}
              except Exception as e:
                  raise HTTPException(status_code=500, detail=f"Task creation failed: {str(e)}")
          
          if __name__ == "__main__":
              import uvicorn
              uvicorn.run(app, host="0.0.0.0", port=8000)
          EOF
          
          cd /app && python main.py
        ports:
        - containerPort: 8000
          name: http
        env:
        - name: REDIS_URL
          valueFrom:
            configMapKeyRef:
              name: zeus-config
              key: REDIS_URL
        - name: POSTGRES_URL
          valueFrom:
            configMapKeyRef:
              name: zeus-config
              key: POSTGRES_URL
        - name: OPENAI_API_KEY
          valueFrom:
            secretKeyRef:
              name: zeus-secrets
              key: OPENAI_API_KEY
        resources:
          requests:
            memory: "2Gi"
            cpu: "1"
          limits:
            memory: "4Gi"
            cpu: "2"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: zeus-core
  namespace: ac-agentic
  labels:
    app: zeus-core
    component: api
spec:
  ports:
  - port: 8000
    targetPort: 8000
    name: http
  selector:
    app: zeus-core
---
apiVersion: route.openshift.io/v1
kind: Route
metadata:
  name: zeus-core
  namespace: ac-agentic
  labels:
    app: zeus-core
    component: api
spec:
  host: zeus-ac-agentic.apps.prod01.fis-cloud.fpt.com
  to:
    kind: Service
    name: zeus-core
    weight: 100
  port:
    targetPort: http
  tls:
    termination: edge
    insecureEdgeTerminationPolicy: Redirect